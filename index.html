<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture AR Shooter</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1646424915/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1646424915/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: white; display: flex;
            flex-direction: column; align-items: center; justify-content: center; z-index: 100;
        }
        #ui { position: absolute; top: 20px; left: 20px; color: white; z-index: 20; font-size: 24px; pointer-events: none; text-shadow: 2px 2px 4px #000; }
        .loader { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 2s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <div class="loader"></div>
        <div id="status">Initializing AI Models...<br>(Please Allow Camera Access)</div>
    </div>

    <div id="ui">Score: <span id="score">0</span></div>
    <video id="input-video" style="display:none" playsinline></video>
    <canvas id="game-canvas"></canvas>

<script>
/** * GAME CONFIGURATION 
 */
const CONFIG = {
    targetCount: 4,
    spawnRadius: 15,
    aimAssistRadius: 2.0,
    gestureThreshold: 0.05, 
    detectionFrequency: 2 
};

let score = 0;
let isLoaded = false;
let canFire = true;
let frameCount = 0;
const targets = [];
const vfxs = [];

/**
 * THREE.JS SCENE SETUP
 */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);

const light = new THREE.DirectionalLight(0xffffff, 1.5);
light.position.set(0, 10, 10);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

// Aiming Laser
const laserMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
const laserGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-10)]);
const laserLine = new THREE.Line(laserGeometry, laserMaterial);
scene.add(laserLine);

/**
 * GAME MECHANICS
 */
function createTarget() {
    const geometry = new THREE.CylinderGeometry(0.6, 0.6, 0.15, 32);
    const material = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0x555500 });
    const disc = new THREE.Mesh(geometry, material);
    
    const angle = Math.random() * Math.PI * 2;
    disc.position.set(Math.cos(angle) * CONFIG.spawnRadius, Math.sin(angle) * CONFIG.spawnRadius, -10);
    disc.rotation.x = Math.PI / 2;
    
    disc.userData.velocity = new THREE.Vector3().copy(disc.position).multiplyScalar(-0.006);
    scene.add(disc);
    targets.push(disc);
}

function spawnVFX(text, pos, color) {
    const geometry = new THREE.SphereGeometry(0.15, 8, 8);
    const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
    const p = new THREE.Mesh(geometry, material);
    p.position.copy(pos);
    p.userData.life = 1.0;
    scene.add(p);
    vfxs.push(p);
}

/**
 * MEDIAPIPE HAND TRACKING
 */
const videoElement = document.getElementById('input-video');
const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.5
});

hands.onResults((results) => {
    try {
        if (!isLoaded && results.multiHandLandmarks) {
            isLoaded = true;
            document.getElementById('loading-overlay').style.display = 'none';
        }

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // Aiming Point (Index Tip)
            const indexTip = landmarks[8];
            const x = (0.5 - indexTip.x) * 22; 
            const y = (0.5 - indexTip.y) * 16;
            
            const aimPos = new THREE.Vector3(x, y, -10);
            let finalTargetPos = aimPos.clone();

            // Magnetic Aim Assist
            let bestTarget = null;
            let minDist = CONFIG.aimAssistRadius;
            
            targets.forEach(t => {
                const d = aimPos.distanceTo(t.position);
                if (d < minDist) {
                    minDist = d;
                    bestTarget = t;
                }
            });

            if (bestTarget) {
                finalTargetPos.copy(bestTarget.position);
                laserLine.material.color.setHex(0x00ff00);
            } else {
                laserLine.material.color.setHex(0xff0000);
            }

            laserLine.geometry.setFromPoints([new THREE.Vector3(0, -3, 0), finalTargetPos]);

            // Shooting Gesture (Thumb to Index Base)
            const thumbTip = landmarks[4];
            const indexBase = landmarks[5];
            const triggerDist = Math.hypot(thumbTip.x - indexBase.x, thumbTip.y - indexBase.y);
            
            if (triggerDist < CONFIG.gestureThreshold && canFire) {
                handleShoot(bestTarget, finalTargetPos);
                canFire = false;
                setTimeout(() => { canFire = true; }, 400); 
            }
        }
    } catch (err) {
        console.error("Tracking Error:", err);
    }
});

function handleShoot(target,
